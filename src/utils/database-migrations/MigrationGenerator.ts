import * as fs from "fs";
import * as path from "path";
import * as CONFIG from "migrationsconfig";
import { createFile } from "../database-migrations/utils";
import {
  MigrationSqls,
  GeneratorOptions,
  DatabaseUnitType,
} from "./interfaces";
import { MigrationUtils } from "./MigrationUtils";
import { MigrationFactory } from "./MigrationFactory";

/**
 * Generates or updates the migration file with the changes for:
 * Triggers, Routines, Extensions and Calculated Table's fields.
 */
export class MigrationGenerator {
  options: GeneratorOptions;
  databaseUnitTypes: DatabaseUnitType[];

  constructor(options: GeneratorOptions) {
    this.setOptions(options);
  }

  setOptions(options: GeneratorOptions) {
    const defaultOptions = {
      updateLastMigration: false,
    };
    this.options = Object.assign({}, defaultOptions, options);
    this.databaseUnitTypes =
      options.databaseUnitType === "all"
        ? ["function", "procedure", "trigger", "customField", "extension"]
        : [options.databaseUnitType];
  }

  /**
   * Insert the up a down content in the template string and creates the migration files.
   * @param migrationSqls Migration function array.
   * @return A promise when the file is created.
   */
  async createMigrationFile(migrationSqls: MigrationSqls): Promise<void> {
    try {
      const timestamp = new Date().getTime();
      const content = MigrationUtils.buildMigrationContent(migrationSqls);
      const fileContent = MigrationUtils.getTemplate(
        this.options.migrationName,
        timestamp,
        content
      );
      const filename = timestamp + "-" + this.options.migrationName + ".ts";
      let directory = CONFIG.MIGRATIONS_PATH;
      const filePath = path.join(
        process.cwd(),
        directory ? directory + "/" : "",
        filename
      );
      await createFile(filePath, fileContent);
      console.log(`Migration has been generated successfully.`);
    } catch (err) {
      console.log("Error during migration creation:");
      console.error(err);
    }
  }

  /**
   * Update the migration file generated by TypeORM and include the changes of
   * triggers and functions in the up and down methods.
   * If the custom option is true, then also include the queries for the calculated fields.
   * @param fileName The file generated by TypeORM.
   * @param migrationSqls Migration function array.
   * @return A promise when the file is updated.
   */
  //TODO: #CU-2949ew Research about a tool to merge files
  async modifyMigrationFile(
    fileName: string,
    migrationSqls: MigrationSqls
  ): Promise<void> {
    const fileData = fs
      .readFileSync(path.join(CONFIG.MIGRATIONS_PATH, fileName))
      .toString();
    const lines = fileData.split("\n");
    const content = MigrationUtils.buildMigrationContent(migrationSqls);
    lines.splice(6, 0, "        " + content.up);
    lines.splice(lines.length - 4, 0, "        " + content.down);
    const unitedData = lines.join("\n");
    fs.writeFileSync(path.join(CONFIG.MIGRATIONS_PATH, fileName), unitedData);
    const partsFileName = fileName.split("-");
    const newFileName = `${partsFileName[0]}-${this.options.migrationName}.ts`;
    fs.renameSync(
      path.join(CONFIG.MIGRATIONS_PATH, fileName),
      path.join(CONFIG.MIGRATIONS_PATH, newFileName)
    );
  }

  /**
   * If TypeORM detects changes in the entities or the views, it will generate a migration file,
   * so we get that fileName an modify its content with the changes of the structures (triggers, routines, etc)
   * If TypeORM does not generate a file, then it calls the createMigrationFile.
   * @param migrationSqls Migration function array.
   * @return A promise when the file is created or updated.
   */
  async createOrUpdateMigrationFile(
    migrationSqls: MigrationSqls
  ): Promise<void> {
    try {
      const fileName = await MigrationUtils.getMostRecentMigrationFile();
      if (!fileName) {
        await this.createMigrationFile(migrationSqls);
      } else {
        await this.modifyMigrationFile(fileName, migrationSqls);
      }
    } catch (err) {
      console.log("Error during migration update:");
      console.error(err);
    }
  }

  /**
   * Map the structures with changes and decide if we create migration file for the changes of the structures,
   * or if we choose the 'all' option, then update the generated file by TypeORM.
   * Note: If the option property is 'extension' then the databaseStructures will be extensions.
   * @return A promise when the file is generated.
   */
  async generate(): Promise<void> {
    const databaseMigrations = await MigrationFactory.getDatabaseUnitMigrations(
      this.databaseUnitTypes
    );
    const migrationSqls: MigrationSqls = {
      upSqls: [],
      downSqls: [],
    };
    for (const migration of databaseMigrations) {
      await migration.build();
      migrationSqls.upSqls.push(...migration.upSqls);
      migrationSqls.downSqls.push(...migration.downSqls);
    }
    if (this.options.updateLastMigration) {
      await this.createOrUpdateMigrationFile(migrationSqls);
    } else {
      await this.createMigrationFile(migrationSqls);
    }
  }
}
