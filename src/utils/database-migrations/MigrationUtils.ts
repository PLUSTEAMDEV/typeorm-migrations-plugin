import * as path from "path";
import * as fs from "fs";
import {
  MigrationFileContent,
  MigrationSqls,
  PsqlUnitType,
} from "./interfaces";
import * as CONFIG from "migrationsconfig.json";
import { format } from "@sqltools/formatter/lib/sqlFormatter";
import { GitChangedFilesDetector } from "./GitChangedFilesDetector";
import { getFilteredFilesFromPath } from "./utils";

export class MigrationUtils {
  /**
   * Construct the template string with its content.
   * @param name Name of the migration file.
   * @param timestamp Timestamp when the file was created.
   * @param content Content for the up and down functions.
   * @return the template string.
   */
  static getTemplate(
    name: string,
    timestamp: number,
    content: MigrationFileContent
  ): string {
    return `import {MigrationInterface, QueryRunner} from "typeorm";
export class ${name}${timestamp} implements MigrationInterface {
    name = '${name}${timestamp}';
    public async up(queryRunner: QueryRunner): Promise<void> {
        ${content.up}
    }
    public async down(queryRunner: QueryRunner): Promise<void> {
        ${content.down}
    }
}`;
  }

  /**
   * Gets the "all-migrations" file generated by the generate:migrations:all command.
   * If the last file in the directory does not include "all-migrations" then returns "";
   * @return file name of the migration file generated.
   */
  //TODO: #CU-2943u4 Improve the process of the most recent migration file
  static async getMostRecentMigrationFile(): Promise<string> {
    let dir = path.resolve(CONFIG.MIGRATIONS_PATH);
    let files = fs.readdirSync(dir);
    return files[files.length - 1].includes("all-migrations")
      ? files[files.length - 1]
      : "";
  }

  /**
   * Formats the sql query with blank spaces.
   * @param query Filepath to the directory.
   * @return formatted query.
   */
  static prettifyQuery(query: string) {
    const formattedQuery = format(query, { indent: "    " });
    return "\n" + formattedQuery.replace(/^/gm, "            ") + "\n        ";
  }

  static getPsqlUnitTypeChangedFiles(psqlUnitType: PsqlUnitType) {
    const isExpectedPsqlUnitType = (filename: string) =>
      filename.includes(CONFIG.MIGRATION_ROUTES[psqlUnitType].path);
    return GitChangedFilesDetector.getChangedFiles().filter((filename) =>
      isExpectedPsqlUnitType(filename)
    );
  }

  static getTriggersPaths(): string[] {
    const triggerPaths: string[] = [];
    const entitiesDirectories = fs.readdirSync(CONFIG.ENTITIES_PATH);
    for (let directory of entitiesDirectories) {
      const triggersDirectory = path.join(
        CONFIG.ENTITIES_PATH,
        directory,
        CONFIG.MIGRATION_ROUTES.trigger.path
      );
      if (fs.existsSync(triggersDirectory)) {
        const files = getFilteredFilesFromPath(triggersDirectory, "ts");
        files.forEach((file: string) =>
          triggerPaths.push(path.join(triggersDirectory, file))
        );
      }
    }
    return triggerPaths;
  }

  static getRoutinesPaths(psqlUnitType: PsqlUnitType): string[] {
    let routinesPaths: string[] = [];
    const files = getFilteredFilesFromPath(
      CONFIG.MIGRATION_ROUTES[psqlUnitType].path,
      "ts"
    );
    files.forEach((file: string) =>
      routinesPaths.push(
        path.join(CONFIG.MIGRATION_ROUTES[psqlUnitType].path, file)
      )
    );
    return routinesPaths;
  }

  static async getPsqlUnitTypePaths(): Promise<string[]> {
    let psqlUnitPaths = [];
    const getUnitPathsMap: Record<PsqlUnitType, () => Promise<string[]>> = {
      trigger: MigrationUtils.getTriggersPaths.bind(null),
      function: MigrationUtils.getRoutinesPaths.bind(null, "function"),
      procedure: MigrationUtils.getRoutinesPaths.bind(null, "procedure"),
    };
    const psqlUnitTypes: PsqlUnitType[] = ["trigger", "function", "procedure"];
    for (const unit of psqlUnitTypes) {
      const unitsPaths = await getUnitPathsMap[unit];
      psqlUnitPaths.push(...(await unitsPaths()));
    }
    return psqlUnitPaths;
  }

  static buildMigrationContent(
    migrationsSqls: MigrationSqls
  ): MigrationFileContent {
    const formatSqlToQueryRunnerSentence = (query: string) =>
      `\t\t\t\tawait queryRunner.query(\`${this.prettifyQuery(query)}\`);\n`;
    let up: string = "";
    let down: string = "";
    for (const upSql of migrationsSqls.upSqls) {
      up += formatSqlToQueryRunnerSentence(upSql);
    }
    for (const downSql of migrationsSqls.downSqls) {
      down += formatSqlToQueryRunnerSentence(downSql);
    }
    return {
      up,
      down,
    };
  }
}
