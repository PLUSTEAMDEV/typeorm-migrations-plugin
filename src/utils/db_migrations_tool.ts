import { format } from "@sqltools/formatter/lib/sqlFormatter";
import * as fs from "fs";
import * as path from "path";
const ORM_CONFIG = require("ormconfig");
const mkdirp = require("mkdirp");
const cgf = require("changed-git-files");
import {
  MigrationFunctions,
  databaseStructure,
  queryRunner,
  modifiedFile,
  queryRunnerFunction,
} from "@/utils/interfaces";
import { CONSTRUCTED_EXTENSIONS } from "@/utils/db_tools";

let args = process.argv.slice(2);

class MigrationGenerator {
  name: string;
  option: string;
  structuresChanged: databaseStructure[];

  constructor(name: string, option: string, structures: modifiedFile[]) {
    this.name = name;
    this.option = option;
    this.structuresChanged = structures
      .map((files: modifiedFile) => this.getStructure(files.filename))
      .filter((structure: databaseStructure) =>
        this.isMigrationRoute(structure)
      );
  }

  unitedData
  isMigrationRoute(structure: databaseStructure): boolean {
    return (
      (structure.logicType == args[0] || args[0] == "all") &&
      (structure.path.includes(ORM_CONFIG[1][0]) ||
        structure.path.includes(ORM_CONFIG[1][1]))
    );
  }

  getStructure(filename): databaseStructure {
    return {
      path: filename.replace(".ts", ""),
      logicType: filename.includes(ORM_CONFIG[1][0]) ? "function" : "trigger",
    };
  }

  async createFile(
    filePath: string,
    content: string,
    override: boolean = true
  ): Promise<void> {
    await mkdirp(path.dirname(filePath));
    return new Promise<void>((ok, fail) => {
      if (override === false && fs.existsSync(filePath)) return ok();
      fs.writeFile(filePath, content, (err) => (err ? fail(err) : ok()));
    });
  }

  prettifyQuery(query: string) {
    const formattedQuery = format(query, { indent: "    " });
    return "\n" + formattedQuery.replace(/^/gm, "            ") + "\n        ";
  }

  getTemplate(
    name: string,
    timestamp: number,
    logic: queryRunnerFunction
  ): string {
    return `import {MigrationInterface, QueryRunner} from "typeorm";
export class ${name}${timestamp} implements MigrationInterface {
    name = '${name}${timestamp}'
    public async up(queryRunner: QueryRunner): Promise<void> {
        ${logic.up}
    }
    public async down(queryRunner: QueryRunner): Promise<void> {
        ${logic.down}
    }
}`;
  }

  getQueryRunner(query: MigrationFunctions): queryRunner {
    let queryRunners: queryRunner = { up: [], down: [] };
    queryRunners.up.push(
      `await queryRunner.query(\`${this.prettifyQuery(query.up.create)}\`);`
    );
    if ("afterCreated" in query.up) {
      queryRunners.up.push(
        `await queryRunner.query(\`${this.prettifyQuery(
          query.up.afterCreated
        )}\`);`
      );
    }
    queryRunners.down.push(
      `await queryRunner.query(\`${query.down}\`);`
    );
    return queryRunners;
  }

  createUpAndDownFunctions(queries: MigrationFunctions[]): queryRunnerFunction {
    const queryRunners = queries.map((query: MigrationFunctions) =>
      this.getQueryRunner(query)
    );
    return {
      up: queryRunners
        .map((queryRunner: queryRunner) => queryRunner.up.join("\n        "))
        .join("\n        "),
      down: queryRunners
        .map((queryRunner: queryRunner) => queryRunner.down)
        .join("\n        "),
    };
  }
  async createMigrationFile(queries: MigrationFunctions[]): Promise<void> {
    try {
      const timestamp = new Date().getTime();
      const logic = this.createUpAndDownFunctions(queries);
      const fileContent = this.getTemplate(this.name, timestamp, logic);
      const filename = timestamp + "-" + this.name + ".ts";
      let directory = "src/migration";
      const pathOfFile =
        process.cwd() + "/" + (directory ? directory + "/" : "") + filename;
      await this.createFile(pathOfFile, fileContent);
      console.log(`Migration has been generated successfully.`);
    } catch (err) {
      console.log("Error during migration creation:");
      console.error(err);
    }
  }

  /**
   * Gets the "all-migrations" file name generated by the generate:migrations:all command.
   * If the last file in the directory does not include "all-migrations" then returns "";
   * @return file name of the migration file generated.
   */
  async getMostRecentMigrationFile(): Promise<string> {
    let dir = path.resolve("src/migration");
    let files = fs.readdirSync(dir);
    return files[files.length-1].includes("all-migrations") ? files[files.length-1]: "";
  }

  /**
   * Update the migration file generated by TypeORM and include the changes of
   * triggers and functions in the up and down methods.
   */
  async modifyMigrationFile(fileName: string, queries: MigrationFunctions[]) {
    const fileData = fs.readFileSync(`src/migration/${fileName}`).toString();
    const lines = fileData.split("\n");
    const logic = this.createUpAndDownFunctions(queries);
    lines.splice(6, 0, "        " + logic.up);
    lines.splice(lines.length - 4, 0, "        " + logic.down);
    const unitedData = lines.join("\n");
    fs.writeFileSync(`src/migration/${fileName}`, unitedData);
    const partsFileName = fileName.split("-");
    const newFileName = `${partsFileName[0]}-${this.name}.ts`;
    fs.renameSync(`src/migration/${fileName}`, `src/migration/${newFileName}`);
  }

  async updateMigrationFile(queries: MigrationFunctions[]): Promise<void> {
    try {
      const fileName = await this.getMostRecentMigrationFile();
      if (!fileName) {
        await this.createMigrationFile(queries);
      } else {
        await this.modifyMigrationFile(fileName, queries);
      }
    } catch (err) {
      console.log("Error during migration update:");
      console.error(err);
    }
  }
  async generate(): Promise<void> {
    if (this.structuresChanged.length === 0) {
      console.log("There are not changes in the structures.");
      return;
    }
    let queries;
    if (this.option == "extension") {
      queries = CONSTRUCTED_EXTENSIONS;
    } else {
      queries = this.structuresChanged.map(
        (structure: databaseStructure) => require(structure.path).default
      );
    }
    if (this.option != "all"){
      await this.createMigrationFile(queries);
    } else {
      await this.updateMigrationFile(queries);
    }
  }
}

cgf(async function (err, results): Promise<void> {
  const generator = new MigrationGenerator(args[1], args[0], results);
  await generator.generate();
});
